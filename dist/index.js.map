{"version":3,"file":"index.js","sources":["../node_modules/fast-memoize/src/index.js","../src/service/common.js","../src/service/core.js","../src/components/Form.vue","../node_modules/debounce/index.js","../src/components/Field.vue","../src/components/FieldArray.vue","../src/service/customize.js"],"sourcesContent":["//\n// Main\n//\n\nfunction memoize (fn, options) {\n  var cache = options && options.cache\n    ? options.cache\n    : cacheDefault\n\n  var serializer = options && options.serializer\n    ? options.serializer\n    : serializerDefault\n\n  var strategy = options && options.strategy\n    ? options.strategy\n    : strategyDefault\n\n  return strategy(fn, {\n    cache: cache,\n    serializer: serializer\n  })\n}\n\n//\n// Strategy\n//\n\nfunction isPrimitive (value) {\n  return value == null || typeof value === 'number' || typeof value === 'boolean' // || typeof value === \"string\" 'unsafe' primitive for our needs\n}\n\nfunction monadic (fn, cache, serializer, arg) {\n  var cacheKey = isPrimitive(arg) ? arg : serializer(arg)\n\n  var computedValue = cache.get(cacheKey)\n  if (typeof computedValue === 'undefined') {\n    computedValue = fn.call(this, arg)\n    cache.set(cacheKey, computedValue)\n  }\n\n  return computedValue\n}\n\nfunction variadic (fn, cache, serializer) {\n  var args = Array.prototype.slice.call(arguments, 3)\n  var cacheKey = serializer(args)\n\n  var computedValue = cache.get(cacheKey)\n  if (typeof computedValue === 'undefined') {\n    computedValue = fn.apply(this, args)\n    cache.set(cacheKey, computedValue)\n  }\n\n  return computedValue\n}\n\nfunction assemble (fn, context, strategy, cache, serialize) {\n  return strategy.bind(\n    context,\n    fn,\n    cache,\n    serialize\n  )\n}\n\nfunction strategyDefault (fn, options) {\n  var strategy = fn.length === 1 ? monadic : variadic\n\n  return assemble(\n    fn,\n    this,\n    strategy,\n    options.cache.create(),\n    options.serializer\n  )\n}\n\nfunction strategyVariadic (fn, options) {\n  var strategy = variadic\n\n  return assemble(\n    fn,\n    this,\n    strategy,\n    options.cache.create(),\n    options.serializer\n  )\n}\n\nfunction strategyMonadic (fn, options) {\n  var strategy = monadic\n\n  return assemble(\n    fn,\n    this,\n    strategy,\n    options.cache.create(),\n    options.serializer\n  )\n}\n\n//\n// Serializer\n//\n\nfunction serializerDefault () {\n  return JSON.stringify(arguments)\n}\n\n//\n// Cache\n//\n\nfunction ObjectWithoutPrototypeCache () {\n  this.cache = Object.create(null)\n}\n\nObjectWithoutPrototypeCache.prototype.has = function (key) {\n  return (key in this.cache)\n}\n\nObjectWithoutPrototypeCache.prototype.get = function (key) {\n  return this.cache[key]\n}\n\nObjectWithoutPrototypeCache.prototype.set = function (key, value) {\n  this.cache[key] = value\n}\n\nvar cacheDefault = {\n  create: function create () {\n    return new ObjectWithoutPrototypeCache()\n  }\n}\n\n//\n// API\n//\n\nmodule.exports = memoize\nmodule.exports.strategies = {\n  variadic: strategyVariadic,\n  monadic: strategyMonadic\n}\n","import Vue from 'vue';\nimport memoize from 'fast-memoize';\n\nconst INFINITY = 1 / 0;\nconst ESCAPE_CHARACTERS = /\\\\(\\\\)?/g;\nconst PROP_NAMES = RegExp(\n\t'[^.[\\\\]]+' + '|' +\n\t// Or match property names within brackets.\n\t'\\\\[(?:' +\n\t// Match a non-string expression.\n\t'([^\"\\'][^[]*)' + '|' +\n\t// Or match strings (supports escaping characters).\n\t'([\"\\'])((?:(?!\\\\2)[^\\\\\\\\]|\\\\\\\\.)*?)\\\\2' +\n\t')\\\\]'+ '|' +\n\t// Or match \"\" as the space between consecutive dots or empty brackets.\n\t'(?=(?:\\\\.|\\\\[\\\\])(?:\\\\.|\\\\[\\\\]|$))'\n\t, 'g');\n\nexport function deepcopy(obj) {\n\treturn JSON.parse(JSON.stringify(obj));\n}\n\nexport function isUndefined(obj) {\n\treturn typeof obj === 'undefined';\n}\n\nexport function isPromise(obj) {\n\treturn !!obj && (typeof obj === 'object' || typeof obj === 'function') && typeof obj.then === 'function';\n}\n\nexport function isString(obj) {\n\treturn typeof obj === 'string';\n}\n\nexport function isBoolean(obj) {\n\treturn typeof obj === 'boolean';\n}\n\nexport function isObject(obj) {\n\treturn obj !== null && typeof obj === 'object';\n}\n\nexport function isNull(obj) {getValue;\n\treturn obj === null;\n}\n\nexport function isArray(obj) {\n\treturn Array.isArray(obj);\n}\n\nexport function isFunction(obj) {\n\treturn obj && (Object.prototype.toString.call(obj) === '[object Function]' || 'function' === typeof obj || obj instanceof Function);\n}\n\nexport function isSymbol(obj) {\n\treturn (obj && ((typeof obj === 'symbol')\n\t\t|| (obj['@@toStringTag'] === 'Symbol')\n\t\t|| toString.call(obj) === '[object Symbol]')) || false;\n}\n\nexport function isInteger(obj) {\n\treturn String(Math.floor(Number(obj))) === obj;\n}\n\nexport function getValue(obj, key, defaultValue = null) {\n\treturn key in obj ? obj[key] : defaultValue;\n}\n\nexport function ownProperties(obj) {\n\treturn Object.keys(obj);\n}\n\nexport function flatten(obj) {\n\tconst queue = [{\n\t\telement: obj,\n\t\tparent: null\n\t}];\n\tconst result = [];\n\twhile (queue.length) {\n\t\tlet node = queue.pop();\n\t\tif (isObject(node.element) || isArray(node.element)) {\n\t\t\tfor (const field of ownProperties(node.element)) {\n\t\t\t\tqueue.push({\n\t\t\t\t\tname: field,\n\t\t\t\t\telement: node.element[field],\n\t\t\t\t\tparent: node\n\t\t\t\t});\n\t\t\t}\n\t\t} else {\n\t\t\tconst element = node.element;\n\t\t\tlet branch = '';\n\t\t\twhile (node.parent !== null) {\n\t\t\t\tbranch = (isArray(node.parent.element) ? `[${node.name}]` : `${node.parent.parent ? '.' : ''}${node.name}`) + branch;\n\t\t\t\tnode = node.parent;\n\t\t\t}\n\t\t\tresult[branch] = element;\n\t\t}\n\t}\n\treturn result;\n}\n\n\nexport function getIn(object, pathString, defaultValue) {\n\tconst path = toPath(pathString);\n\n\tlet index = 0;\n\twhile (object && index < path.length) {\n\t\tobject = object[path[index++]];\n\t}\n\n\treturn object === undefined ? defaultValue : object;\n}\n\nexport function insertToArray(array, index, value, defaultValue) {\n\tconst length = array.length;\n\tif (length > index) {\n\t\tarray.splice(index, 1, value);\n\t} else {\n\t\tfor (let i = 0; i < index - length; i++) {\n\t\t\tarray.push(defaultValue);\n\t\t}\n\t\tarray.push(value);\n\t}\n\treturn array;\n}\n\nexport function setValueByPath(object, pathString, value, defaultValue) {\n\tconst path = toPath(pathString);\n\n\tlet previousElement = object;\n\tfor (let index = 0; index < path.length; index++) {\n\t\tconst isLast = index === path.length - 1;\n\t\tconst currentElement = getIn(object, path.slice(0, index + 1));\n\t\tif (!currentElement || isLast || !isObject(currentElement) && !isArray(currentElement)) {\n\t\t\tconst nextValue = isLast ? value : (isInteger(path[index + 1]) && Number(path[index + 1]) >= 0 ? [] : {});\n\t\t\tif (isArray(previousElement)) {\n\t\t\t\tinsertToArray(previousElement, path[index], nextValue);\n\t\t\t} else {\n\t\t\t\tVue.set(previousElement, path[index], isUndefined(nextValue) ? defaultValue : nextValue);\n\t\t\t}\n\t\t}\n\t\tpreviousElement = getIn(object, path.slice(0, index + 1));\n\t}\n}\n\nexport function removeValueByPath(object, pathString) {\n\tconst path = toPath(pathString);\n\n\tlet previousElement = getIn(object, path.slice(0, path.length - 1));\n\tlet removedElement = path[path.length - 1];\n\n\tif (isArray(previousElement)) {\n\t\tconst index = Number(removedElement);\n\t\tif (index === previousElement.length - 1) {\n\t\t\tpreviousElement.pop();\n\t\t} else if (index < previousElement.length - 1) {\n\t\t\tpreviousElement[index] = null;\n\t\t}\n\t} else {\n\t\tif (previousElement) {\n\t\t\tVue.delete(previousElement, removedElement);\n\t\t}\n\t}\n}\n\nexport function freeze(object) {\n\treturn Object.assign({}, object);\n}\n\nconst stringToPath = memoize((string, delimiter='.') => {\n\tconst result = [];\n\tif (string.charCodeAt(0) === delimiter.charCodeAt(0)) {\n\t\tresult.push('');\n\t}\n\tstring.replace(PROP_NAMES, (match, expression, quote, subString) => {\n\t\tlet key = match;\n\t\tif (quote) {\n\t\t\tkey = subString.replace(ESCAPE_CHARACTERS, '$1');\n\t\t}\n\t\telse if (expression) {\n\t\t\tkey = expression.trim();\n\t\t}\n\t\tresult.push(key);\n\t});\n\treturn result;\n});\n\nfunction toKey(value) {\n\tif (typeof value === 'string' || isSymbol(value)) {\n\t\treturn value;\n\t}\n\tconst result = `${value}`;\n\treturn (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;\n}\n\nexport function splitOnPathAndIndex(name) {\n\tconst path = toPath(name);\n\treturn [\n\t\tpath.slice(0, path.length - 1),\n\t\tpath[path.length - 1]\n\t];\n}\n\nexport function processName(path) {\n\tconst result = path.match(/(.*?)\\[(\\d+)\\]?$/);\n\tif (result) {\n\t\treturn [result[1], result[2]];\n\t} else {\n\t\treturn [null, null];\n\t}\n}\n\nexport function toPath(value) {\n\tif (Array.isArray(value)) {\n\t\treturn value.map(toKey);\n\t}\n\treturn isSymbol(value) ? [value] : [...stringToPath(value)];\n}\n\nexport function isEqual(a, b) {\n\treturn a == b;\n}\n\nexport function defaultMergeAlgorithm(source, destination, name, defaultValue) {\n\tif (isArray(destination)) {\n\t\treturn [...destination, ...source.filter(a => destination.find(b => isEqual(a, b)))];\n\t} else {\n\t\treturn (isUndefined(destination) || isEqual(destination, defaultValue)) ? source : destination;\n\t}\n}\n\nexport function mergeValidations(array, settings, mergeAlgorithm = defaultMergeAlgorithm) {\n\tconst result = {};\n\tif (isArray(array)) {\n\t\tconst blocks = array.reduce((value, block) => (isArray(block) ? value.concat(block) : value.concat([block])), []);\n\t\tblocks.forEach(fields => {\n\t\t\tif (isObject(fields)) {\n\t\t\t\t// traverse meta\n\t\t\t\tfor (const name of ownProperties(fields)) {\n\t\t\t\t\tif (isObject(fields[name])) {\n\t\t\t\t\t\t// traverse fields\n\t\t\t\t\t\tif (result[name]) {\n\t\t\t\t\t\t\tfor (const meta of ownProperties(fields[name])) {\n\t\t\t\t\t\t\t\tif (meta in result[name]) {\n\t\t\t\t\t\t\t\t\tresult[name][meta] = mergeAlgorithm(fields[name][meta], result[name][meta], meta, settings[meta].default);\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tresult[name][meta] = fields[name][meta];\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tresult[name] = { ...fields[name] };\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tconsole.warn('The merging validations should be objects');\n\t\t\t}\n\t\t});\n\t} else {\n\t\tconsole.warn('The first argument of mergeValidations function should be array');\n\t}\n\treturn result;\n}\n\n\nexport function updateArray(value, newValue) {\n\tif (value.length > newValue.length) {\n\t\tvalue.splice(0, newValue.length);\n\t}\n\tfor (let i = 0; i < value.length; i++) {\n\t\tif (!isEqual(value[i], newValue[i])) {\n\t\t\tVue.set(value, i, newValue[i]);\n\t\t}\n\t}\n\tif (value.length < newValue.length) {\n\t\tfor (let i = value.length; i < newValue.length; i++) {\n\t\t\tvalue.push(newValue[i]);\n\t\t}\n\t}\n}\n\nexport function flattenMeta(obj) {\n\tconst result = {};\n\n\tfor (const meta of ownProperties(obj)) {\n\t\tconst queue = [\n\t\t\t{\n\t\t\t\telement: obj[meta],\n\t\t\t\tparent: null\n\t\t\t}\n\t\t];\n\t\twhile (queue.length) {\n\t\t\tlet node = queue.pop();\n\t\t\tif (isObject(node.element) || isArray(node.element)) {\n\t\t\t\tfor (const field of ownProperties(node.element)) {\n\t\t\t\t\tqueue.push({\n\t\t\t\t\t\tname: field,\n\t\t\t\t\t\telement: node.element[field],\n\t\t\t\t\t\tparent: node\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tconst value = node.element;\n\t\t\t\tlet branch = '';\n\t\t\t\twhile (node.parent !== null) {\n\t\t\t\t\tif (isArray(node.parent.element)) {\n\t\t\t\t\t\tbranch = `[${node.name}]` + branch;\n\t\t\t\t\t} else if (node.name !== '$self' && node.name !== '$children') {\n\t\t\t\t\t\tbranch = `${node.parent.parent ? '.' : ''}${node.name}` + branch;\n\t\t\t\t\t}\n\t\t\t\t\tnode = node.parent;\n\t\t\t\t}\n\t\t\t\tif (!result[branch]) {\n\t\t\t\t\tresult[branch] = {};\n\t\t\t\t}\n\t\t\t\tresult[branch][meta] = value;\n\t\t\t}\n\t\t}\n\t}\n\treturn result;\n}\n\nexport function arrayToObject(array, names) {\n\tconst result = {};\n\tnames.forEach((name, index) => {\n\t\tresult[name] = array[index];\n\t});\n\treturn result;\n}\n\n\n","import { isArray, isObject, isFunction, isString, arrayToObject, ownProperties } from './common';\n\nimport Vue from 'vue';\n\nexport const core = {\n\tvalidators: {},\n\tinstall(Vue) {\n\t\tif (!this.installed) {\n\t\t\tthis.installed = true;\n\n\t\t\tthis.vm = new Vue({\n\t\t\t\tdata: {\n\t\t\t\t\tforms: {}\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tVue.mixin({\n\t\t\t\tbeforeCreate: this.init\n\t\t\t});\n\t\t}\n\t},\n\tcreate(name, ref) {\n\t\tif (this.installed) {\n\t\t\tVue.set(this.vm.$data.forms, name, {\n\t\t\t\t...ref.interface()\n\t\t\t});\n\t\t}\n\t},\n\tdelete(name) {\n\t\tif (this.installed) {\n\t\t\tif (this.forms) {\n\t\t\t\tVue.delete(this.forms, name);\n\t\t\t}\n\t\t}\n\t},\n\tinit() {\n\t\tthis.$form = (name) => {\n\t\t\tif (this.installed) {\n\t\t\t\treturn core.vm.$data.forms[name];\n\t\t\t} else {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t};\n\t}\n};\n\nexport function getValidator(rules) {\n\tconst validators = [];\n\tif (isString(rules)) {\n\t\tfor (const rule of rules.split('|')) {\n\t\t\tconst [name, params] = rule.split(':');\n\t\t\tconst scheme         = core.validators[name];\n\t\t\tif (scheme) {\n\t\t\t\tconst arrayParams = params ? params.split(',') : [];\n\t\t\t\tvalidators.push((value) => scheme.validator(value, arrayToObject(arrayParams, scheme.params)));\n\t\t\t} else {\n\t\t\t\tconsole.warn(`There is no global validator with name ${name}`);\n\t\t\t}\n\t\t}\n\t} else if (isObject(rules)) {\n\t\tfor (const name of ownProperties(rules)) {\n\t\t\tconst scheme = core.validators[name];\n\t\t\tvalidators.push((value) => {\n\t\t\t\tif (scheme) {\n\t\t\t\t\tif (isObject(rules[name])) {\n\t\t\t\t\t\tscheme.validator(value, rules[name]);\n\t\t\t\t\t} else if (isArray(rules[name])) {\n\t\t\t\t\t\tscheme.validator(value, arrayToObject(rules[name], scheme.params));\n\t\t\t\t\t} else if (rules[name]) {\n\t\t\t\t\t\tscheme.validator(value, {});\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tconsole.warn(`There is no global validator with name ${name}`);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t}\n\treturn (...value) => {\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tPromise.all(validators.map(validator => validator(...value))).then(validations => {\n\t\t\t\tresolve(validations);\n\t\t\t});\n\t\t});\n\t};\n}\n\nexport function registerValidator(name, scheme) {\n\tif (isFunction(scheme)) {\n\t\tcore.validators[name] = {\n\t\t\tvalidator: scheme,\n\t\t\tparams: [],\n\t\t};\n\t} else {\n\t\tcore.validators[name] = scheme;\n\t}\n}\n","<script>\nimport Vue from 'vue';\n\nimport { core } from '../service/core';\nimport { freeze, isEqual, isFunction, flattenMeta, getValue, deepcopy, removeValueByPath, setValueByPath, getIn, mergeValidations, isUndefined, ownProperties, isObject, isArray, isPromise, isString } from '../service/common';\n\nexport const formDefaults = {\n\tfieldMeta: {\n\t\tdirty: {\n\t\t\tdefault: false\n\t\t},\n\t\ttouched: {\n\t\t\tdefault: false,\n\t\t},\n\t\terror: {\n\t\t\tdefault: null,\n\t\t\tvalidate: true\n\t\t}\n\t},\n\tformMeta: {\n\t\tdirty: {\n\t\t\tdefault: false,\n\t\t\tcomputed({ form }) {\n\t\t\t\treturn form.getFields().some(field => Boolean(field.meta.dirty));\n\t\t\t}\n\t\t},\n\t\tvalid: {\n\t\t\tdefault: true,\n\t\t\tcomputed({ form }) {\n\t\t\t\treturn form.getFields().every(field => !field.mounted || !field.meta.error);\n\t\t\t}\n\t\t},\n\t\tsubmitting: {\n\t\t\tdefault: false,\n\t\t},\n\t\tvalidating: {\n\t\t\tdefault: false,\n\t\t},\n\t\tsubmitCount: {\n\t\t\tdefault: 0\n\t\t}\n\t},\n\tbehavior: {\n\t\tonUnmountField({ form, field }) {\n\t\t\tform.removeField(field.name);\n\t\t},\n\t\tonMountField({ form, field }) {\n\t\t\t// pass\n\t\t},\n\t\tonInitForm({ form }) {\n\t\t\tconst { defaultFormMeta } = this.settings;\n\n\t\t\tform.setMeta(defaultFormMeta);\n\t\t},\n\t\tonResetForm({ form }) {\n\t\t\tconst { defaultFormMeta } = this.settings;\n\n\t\t\tthis.getFields().forEach(field => {\n\t\t\t\tform.resetField(field.name);\n\t\t\t});\n\n\t\t\tform.setMeta(defaultFormMeta);\n\t\t},\n\n\t\tonStartValidate({ form, field }) {\n\t\t\tform.setMeta({\n\t\t\t\tvalidating: true,\n\t\t\t});\n\n\t\t\tconst promises = [];\n\n\t\t\tif (!field || getValue(form.validationOptions, 'formValidate', 'normal') === 'always') {\n\t\t\t\tform.getFields().forEach(({ name }) => {\n\t\t\t\t\tpromises.push({ [name]: form.settings.defaultFieldMeta });\n\t\t\t\t});\n\t\t\t\tpromises.push(form.validateForm().then(flattenMeta));\n\t\t\t}\n\n\t\t\tform.getFieldRefs().forEach(ref => {\n\t\t\t\tif (!field || form.isLinked(field, ref.getName())) {\n\t\t\t\t\tpromises.push(form.validateField(ref));\n\t\t\t\t}\n\t\t\t});\n\n\t\t\treturn Promise.all(promises);\n\t\t},\n\n\t\tonEndValidate({ form, data }) {\n\t\t\t// This function awaits response with the following shape:\n\t\t\t// data = [\n\t\t\t//     {\n\t\t\t//        name: {\n\t\t\t//           error: 'This.field is required'\n\t\t\t//        },\n\t\t\t//        password: {\n\t\t\t//           error: null\n\t\t\t//        }\n\t\t\t//     },\n\t\t\t//     {\n\t\t\t//        password: {\n\t\t\t//           error: 'Password is too easy'\n\t\t\t//        }\n\t\t\t//     }\n\t\t\t// ]\n\t\t\tconsole.log(data)\n\n\t\t\tconst { fieldMeta } = form.settings;\n\t\t\tconst validations = mergeValidations(data, this.fieldMeta);\n\n\t\t\tform.getFields().forEach(field => {\n\t\t\t\tconst updatedMeta = {};\n\t\t\t\tfieldMeta.forEach(meta => {\n\t\t\t\t\tif (meta.validate) {\n\t\t\t\t\t\tif (validations[field.name] && !isUndefined(validations[field.name][meta.name])) {\n\t\t\t\t\t\t\tupdatedMeta[meta.name] = validations[field.name][meta.name];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\tif (ownProperties(updatedMeta).length) {\n\t\t\t\t\tform.setFieldMeta(field.name, updatedMeta);\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tform.setMeta({\n\t\t\t\tvalidating: false,\n\t\t\t});\n\t\t},\n\t\tonStartSubmit({ form, params }) {\n\t\t\tform.setMeta({\n\t\t\t\tsubmitting: true,\n\t\t\t\tsubmitCount: form.meta.submitCount + 1\n\t\t\t});\n\t\t\tform.getFields().forEach(field => {\n\t\t\t\tform.setFieldMeta(field.name, {\n\t\t\t\t\ttouched: true,\n\t\t\t\t});\n\t\t\t});\n\t\t\treturn form.validate().then(() => {\n\t\t\t\tif (form.meta.valid) {\n\t\t\t\t\tif (form.onSubmit) {\n\t\t\t\t\t\treturn form.onSubmit({ form, params, values: freeze(form.values) });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t},\n\t\tonSubmit({ form, params, values }) {\n\n\t\t},\n\t\tonEndSubmit({ form, params }) {\n\t\t\tform.setMeta({\n\t\t\t\tsubmitting: false,\n\t\t\t});\n\t\t}\n\t}\n};\n\nexport default {\n\tprovide() {\n\t\treturn {\n\t\t\t$form: this.interface()\n\t\t};\n\t},\n\tprops: {\n\t\tname: {\n\t\t\ttype: String,\n\t\t},\n\t\tfieldMeta: {\n\t\t\ttype: Object,\n\t\t\tdefault() {\n\t\t\t\treturn formDefaults.fieldMeta;\n\t\t\t}\n\t\t},\n\t\tformMeta: {\n\t\t\ttype: Object,\n\t\t\tdefault() {\n\t\t\t\treturn formDefaults.formMeta;\n\t\t\t}\n\t\t},\n\t\tinitialValues: {\n\t\t\ttype: Object,\n\t\t\tdefault() {\n\t\t\t\treturn {};\n\t\t\t}\n\t\t},\n\t\tinitialFieldsMeta: {\n\t\t\ttype: Object,\n\t\t\tdefault() {\n\t\t\t\treturn {};\n\t\t\t}\n\t\t},\n\t\tinitialFormMeta: {\n\t\t\ttype: Object,\n\t\t\tdefault() {\n\t\t\t\treturn {};\n\t\t\t}\n\t\t},\n\t\tvalidation: {\n\t\t\ttype: Function,\n\t\t},\n\t\tvalidationOptions: {\n\t\t\ttype: Object,\n\t\t\tdefault() {\n\t\t\t\treturn {\n\t\t\t\t\tonChange: true,\n\t\t\t\t\tonBlur: true,\n\t\t\t\t};\n\t\t\t}\n\t\t},\n\t\tcomponent: {\n\t\t\ttype: [String, Object],\n\t\t\tdefault: 'span'\n\t\t},\n\t\tonUnmountField: {\n\t\t\ttype: Function,\n\t\t\tdefault: formDefaults.behavior.onUnmountField\n\t\t},\n\t\tonMountField: {\n\t\t\ttype: Function,\n\t\t\tdefault: formDefaults.behavior.onMountField\n\t\t},\n\t\tonInitForm: {\n\t\t\ttype: Function,\n\t\t\tdefault: formDefaults.behavior.onInitForm\n\t\t},\n\t\tonResetForm: {\n\t\t\ttype: Function,\n\t\t\tdefault: formDefaults.behavior.onResetForm\n\t\t},\n\t\tonStartValidate: {\n\t\t\ttype: Function,\n\t\t\tdefault: formDefaults.behavior.onStartValidate\n\t\t},\n\t\tonEndValidate: {\n\t\t\ttype: Function,\n\t\t\tdefault: formDefaults.behavior.onEndValidate\n\t\t},\n\t\tonChangeField: {\n\t\t\ttype: Function,\n\t\t\tdefault: formDefaults.behavior.onChangeField\n\t\t},\n\t\tonBlurField: {\n\t\t\ttype: Function,\n\t\t\tdefault: formDefaults.behavior.onBlurField\n\t\t},\n\t\tonFocusField: {\n\t\t\ttype: Function,\n\t\t\tdefault: formDefaults.behavior.onFocusField\n\t\t},\n\t\tonSubmit: {\n\t\t\ttype: Function,\n\t\t},\n\t\tonStartSubmit: {\n\t\t\ttype: Function,\n\t\t\tdefault: formDefaults.behavior.onStartSubmit\n\t\t},\n\t\tonEndSubmit: {\n\t\t\ttype: Function,\n\t\t\tdefault: formDefaults.behavior.onEndSubmit\n\t\t}\n\t},\n\tdata() {\n\t\tconst data = {\n\t\t\tcountFields: 0,\n\t\t\tmeta: {},\n\t\t\tvalues: {},\n\t\t\tfields: {}\n\t\t};\n\t\tfor (const name of ownProperties(this.formMeta)) {\n\t\t\tdata.meta[name] = isUndefined(this.initialFormMeta[name]) ? this.formMeta[name].default : this.initialFormMeta[name];\n\t\t}\n\t\treturn data;\n\t},\n\tcomputed: {\n\t\tsettings() {\n\t\t\tconst fieldMeta = ownProperties(this.fieldMeta).map(name => ({\n\t\t\t\tname,\n\t\t\t\t...this.fieldMeta[name]\n\t\t\t}));\n\n\t\t\tconst formMeta = ownProperties(this.formMeta).map(name => ({\n\t\t\t\tname,\n\t\t\t\t...this.formMeta[name]\n\t\t\t}));\n\n\t\t\tconst defaultFieldMeta            = {};\n\t\t\tconst defaultValidatableFieldMeta = {};\n\t\t\tfieldMeta.forEach(meta => {\n\t\t\t\tdefaultFieldMeta[meta.name] = meta.default;\n\t\t\t\tif (meta.validate) {\n\t\t\t\t\tdefaultValidatableFieldMeta[meta.name] = meta.default;\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tconst defaultFormMeta = {};\n\t\t\tformMeta.forEach(meta => {\n\t\t\t\tdefaultFormMeta[meta.name] = meta.default;\n\t\t\t});\n\n\t\t\treturn {\n\t\t\t\tfieldMeta,\n\t\t\t\tformMeta,\n\t\t\t\tdefaultFieldMeta,\n\t\t\t\tdefaultValidatableFieldMeta,\n\t\t\t\tdefaultFormMeta\n\t\t\t};\n\t\t}\n\t},\n\tcreated() {\n\t\tthis.registry = {};\n\t\tthis.values   = deepcopy(isObject(this.initialValues) ? this.initialValues : {});\n\t},\n\tmounted() {\n\t\tif (this.name) {\n\t\t\tcore.create(this.name, this);\n\t\t}\n\t},\n\tdestroyed() {\n\t\tif (this.name && this.$form && this.$form(this.name)) {\n\t\t\tcore.delete(this.name);\n\t\t}\n\t},\n\tmethods: {\n\t\tinterface() {\n\t\t\tconst self = this;\n\t\t\treturn {\n\t\t\t\tget meta() {\n\t\t\t\t\treturn self.meta;\n\t\t\t\t},\n\t\t\t\tget fields() {\n\t\t\t\t\treturn self.fields;\n\t\t\t\t},\n\t\t\t\tget values() {\n\t\t\t\t\treturn self.values;\n\t\t\t\t},\n\t\t\t\tget settings() {\n\t\t\t\t\treturn self.settings;\n\t\t\t\t},\n\t\t\t\tget refs() {\n\t\t\t\t\treturn this.getFieldRefs();\n\t\t\t\t},\n\t\t\t\t// Getters\n\t\t\t\tgetField: this.getField,\n\t\t\t\tgetFields: this.getFields,\n\t\t\t\tgetFieldMeta: this.getFieldMeta,\n\t\t\t\tgetFieldValue: this.getFieldValue,\n\t\t\t\tgetFieldRef: this.getFieldRef,\n\t\t\t\tgetFieldRefs: this.getFieldRefs,\n\t\t\t\t// Actions\n\t\t\t\tcreateField: this.createField,\n\t\t\t\tresetField: this.resetField,\n\t\t\t\tremoveField: this.removeField,\n\t\t\t\tsetFieldMeta: this.setFieldMeta,\n\t\t\t\tsetFieldValue: this.setFieldValue,\n\t\t\t\tsetFieldsMeta: this.setFieldsMeta,\n\t\t\t\tsetMeta: this.setMeta,\n\t\t\t\tvalidate: this.validate,\n\t\t\t\tmountField: this.mountField,\n\t\t\t\tunmountField: this.unmountField,\n\t\t\t\tsubmit: this.submit,\n\t\t\t\t// Behavior\n\t\t\t\tonSubmit: this.onSubmit,\n\t\t\t\t// Props\n\t\t\t\tvalidationOptions: this.validationOptions\n\t\t\t};\n\t\t},\n\n\t\tgetFieldRef(field) {\n\t\t\tif (isString(field)) {\n\t\t\t\treturn this.getFieldRefs(field)[0];\n\t\t\t} else {\n\t\t\t\treturn field;\n\t\t\t}\n\t\t},\n\n\t\tgetFieldRefs(name) {\n\t\t\tif (name) {\n\t\t\t\treturn Object.values(this.registry).filter(el => el.getName() === name).sort(el => el.getName());\n\t\t\t} else {\n\t\t\t\treturn Object.values(this.registry).sort(el => el.getName());\n\t\t\t}\n\t\t},\n\n\t\tgetFieldInterface(field) {\n\t\t\tconst self = this;\n\t\t\treturn {\n\t\t\t\tget mounted() {\n\t\t\t\t\treturn field.mounted;\n\t\t\t\t},\n\t\t\t\tget controlled() {\n\t\t\t\t\treturn field.controlled;\n\t\t\t\t},\n\t\t\t\tget name() {\n\t\t\t\t\treturn field.name;\n\t\t\t\t},\n\t\t\t\tget value() {\n\t\t\t\t\treturn field.value;\n\t\t\t\t},\n\t\t\t\tset value(value) {\n\t\t\t\t\tself.setFieldValue(field.name, value);\n\t\t\t\t},\n\t\t\t\tget meta() {\n\t\t\t\t\treturn field.meta;\n\t\t\t\t},\n\t\t\t\tset meta(value) {\n\t\t\t\t\tself.setFieldValue(field.name, value);\n\t\t\t\t},\n\t\t\t\tget refs() {\n\t\t\t\t\treturn self.getFieldRefs(field.name);\n\t\t\t\t}\n\t\t\t};\n\t\t},\n\t\tgetField(name) {\n\t\t\tconst field = this.fields[name];\n\n\t\t\tif (field) {\n\t\t\t\treturn this.getFieldInterface(field);\n\t\t\t} else {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t},\n\t\tgetFields() {\n\t\t\treturn ownProperties(this.fields).map(name => ({\n\t\t\t\tname: name,\n\t\t\t\tvalue: this.fields[name].value,\n\t\t\t\tmeta: this.fields[name].meta,\n\t\t\t\trefs: this.registry[name],\n\t\t\t\tmounted: this.fields[name].mounted,\n\t\t\t}));\n\t\t},\n\t\tgetInitialValue(name, ref) {\n\t\t\tconst initialValue = getIn(this.initialValues, name);\n\t\t\tconst field        = ref ? ref : this.getFieldRef(name);\n\t\t\tif (!isUndefined(initialValue)) {\n\t\t\t\treturn initialValue;\n\t\t\t} else if (field) {\n\t\t\t\treturn field.getInitialValue();\n\t\t\t} else {\n\t\t\t\treturn '';\n\t\t\t}\n\t\t},\n\t\tgetFieldValue(name) {\n\t\t\treturn getIn(this.values, name);\n\t\t},\n\t\tgetFieldMeta(name, property) {\n\t\t\tconst meta = this.fields[name] ? this.fields[name].meta : {};\n\t\t\tif (property) {\n\t\t\t\treturn meta[property] || undefined;\n\t\t\t} else {\n\t\t\t\treturn meta;\n\t\t\t}\n\t\t},\n\t\tgetInitialFieldMeta(path) {\n\t\t\tconst { fieldMeta } = this.settings;\n\t\t\tconst result      = {};\n\n\t\t\tfor (const meta of fieldMeta) {\n\t\t\t\tresult[meta.name] = getIn(this.initialFieldsMeta[meta.name], path, meta.default);\n\t\t\t}\n\t\t\treturn result;\n\t\t},\n\t\tgetChildren(name) {\n\t\t\treturn Object.keys(this.fields).filter(field => field !== name && field.indexOf(name) === 0);\n\t\t},\n\n\t\tisLinked(firstName, secondName) {\n\t\t\treturn firstName === secondName || firstName.indexOf(secondName) === 0;\n\t\t},\n\t\tregisterField(field) {\n\t\t\t// Generate the id\n\t\t\tconst id          = `$field_${this.countFields}`;\n\t\t\tconst name        = field.getName() || id;\n\t\t\tthis.registry[id] = field;\n\t\t\tthis.countFields += 1;\n\n\t\t\t// Add the id for the Field component\n\t\t\tfield.id = id;\n\n\t\t\treturn {\n\t\t\t\tid, name\n\t\t\t};\n\t\t},\n\t\tremoveField(name) {\n\t\t\tif (this.values) {\n\t\t\t\tremoveValueByPath(this.values, name);\n\t\t\t}\n\t\t\tVue.delete(this.fields, name);\n\t\t},\n\t\tmountField(fieldRef) {\n\t\t\tconst { name }       = this.registerField(fieldRef);\n\t\t\tconst initialMeta  = this.getInitialFieldMeta(name);\n\t\t\tconst initialValue = this.getInitialValue(name, fieldRef);\n\t\t\tif (!this.fields[name]) {\n\t\t\t\tthis.createField(name, initialValue, initialMeta, { mounted: true, controlled: fieldRef.controlled });\n\t\t\t}\n\t\t\tthis.fields[name].mounted = true;\n\t\t\tthis.onMountField({ form: this.interface(), field: fieldRef.interface() });\n\t\t},\n\t\tcreateField(name, initialValue = null, initialMeta = {}, params = {}) {\n\t\t\tconst { fieldMeta }  = this.settings;\n\t\t\tconst filteredMeta = {};\n\t\t\tfieldMeta.forEach(meta => {\n\t\t\t\tif (meta.name in initialMeta) {\n\t\t\t\t\tfilteredMeta[meta.name] = initialMeta[meta.name];\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tlet value = getIn(this.values, name);\n\t\t\tif (isUndefined(value)) {\n\t\t\t\tsetValueByPath(this.values, name, initialValue);\n\t\t\t\tvalue = initialValue;\n\t\t\t}\n\n\t\t\tVue.set(this.fields, name, {\n\t\t\t\t...params,\n\t\t\t\tmeta: filteredMeta,\n\t\t\t\tvalue: value,\n\t\t\t});\n\n\t\t\tthis.updateForm();\n\t\t},\n\n\n\t\tupdateFieldValue(name, value, options) {\n\t\t\tconst fields = [name, ...this.getChildren(name)];\n\n\t\t\tfields.forEach(field => {\n\t\t\t\tconst oldValue = this.fields[field].value;\n\t\t\t\tconst newValue = getIn(this.values, field);\n\t\t\t\tif (oldValue !== newValue) {\n\t\t\t\t\tthis.fields[field].value = newValue;\n\t\t\t\t\tif (isFunction(this.onChangeField)) {\n\t\t\t\t\t\tthis.onChangeField({\n\t\t\t\t\t\t\tform: this,\n\t\t\t\t\t\t\tfield: name,\n\t\t\t\t\t\t\toldValue,\n\t\t\t\t\t\t\tnewValue,\n\t\t\t\t\t\t\toptions\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t\tthis.updateForm();\n\t\t},\n\t\tsetFieldValue(name, value, options = {}) {\n\t\t\treturn new Promise((resolve, reject) => {\n\t\t\t\tif (name in this.fields) {\n\t\t\t\t\tconst field = this.fields[name];\n\t\t\t\t\tif (!field || !field.$controlled || options.forced) {\n\t\t\t\t\t\tsetValueByPath(this.values, name, value);\n\t\t\t\t\t\tthis.updateFieldValue(name, value, options);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis.getFieldRefs(name).forEach(ref => {\n\t\t\t\t\t\t\tref.$emit('change', value);\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tconsole.warn(`Can't set the value for not mounted field ${name}`);\n\t\t\t\t}\n\t\t\t\tVue.nextTick(() => {\n\t\t\t\t\tresolve({ name, value, options });\n\t\t\t\t});\n\t\t\t});\n\t\t},\n\t\tsetFieldMeta(name, value) {\n\n\t\t\treturn new Promise((resolve, reject) => {\n\t\t\t\tif (name in this.fields) {\n\t\t\t\t\tconst { fieldMeta } = this.settings;\n\t\t\t\t\tfieldMeta.forEach(meta => {\n\t\t\t\t\t\tif (meta.name in value) {\n\t\t\t\t\t\t\tif (this.fields[name].meta[meta.name] !== value[meta.name]) {\n\t\t\t\t\t\t\t\tthis.fields[name].meta[meta.name] = value[meta.name];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t\tthis.updateForm();\n\t\t\t\t} else {\n\t\t\t\t\tconsole.warn(`Can't set the meta for not existing field ${name}`);\n\t\t\t\t}\n\t\t\t\tVue.nextTick(() => {\n\t\t\t\t\tresolve({ name, value });\n\t\t\t\t});\n\t\t\t});\n\t\t},\n\n\t\tresetField(name) {\n\t\t\tconst initialValue = this.getInitialValue(name);\n\t\t\tconst initialMeta  = this.getInitialFieldMeta(name);\n\n\t\t\tif (!this.fields[name].controlled && initialValue) {\n\t\t\t\tthis.setFieldValue(name, initialValue, {\n\t\t\t\t\tinternal: true\n\t\t\t\t});\n\t\t\t}\n\t\t\tthis.setFieldMeta(name, initialMeta);\n\t\t},\n\n\t\tunmountField(fieldRef) {\n\t\t\tconst name = fieldRef.getName();\n\t\t\tdelete this.registry[fieldRef.id];\n\t\t\tif (this.fields[name]) {\n\t\t\t\tthis.fields[name].mounted = this.getFieldRefs(name).length > 0;\n\t\t\t}\n\t\t\tif (this.onUnmountField) {\n\t\t\t\tthis.onUnmountField({ form: this.interface(), field: fieldRef.interface() });\n\t\t\t}\n\t\t},\n\n\t\tsetMeta(value, preventUpdate = false) {\n\t\t\tconst { formMeta } = this.settings;\n\t\t\tformMeta.forEach(meta => {\n\t\t\t\tif (meta.name in value) {\n\t\t\t\t\tif (meta.name in this.meta) {\n\t\t\t\t\t\tthis.meta[meta.name] = value[meta.name];\n\t\t\t\t\t} else {\n\t\t\t\t\t\tVue.set(this.meta, meta.name, value[meta.name]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t\tif (!preventUpdate) {\n\t\t\t\tthis.updateForm();\n\t\t\t}\n\t\t},\n\t\tvalidateForm() {\n\t\t\tconst validator = this.validation;\n\t\t\treturn new Promise((resolve, reject) => {\n\t\t\t\tif (validator) {\n\t\t\t\t\tconst value = validator(this.values);\n\t\t\t\t\tif (isPromise(value)) {\n\t\t\t\t\t\tvalue.then((response) => {\n\t\t\t\t\t\t\tresolve(response);\n\t\t\t\t\t\t});\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresolve(value);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tresolve({});\n\t\t\t\t}\n\t\t\t});\n\t\t},\n\t\tvalidateField(field) {\n\t\t\tconst name = field.getName();\n\t\t\tconst { defaultValidatableFieldMeta } = this.settings;\n\t\t\treturn new Promise((resolve, reject) => {\n\t\t\t\tif (field.onValidate) {\n\t\t\t\t\tconst value = field.onValidate({ field: field.interface(), form: this.interface() });\n\t\t\t\t\tif (isPromise(value)) {\n\t\t\t\t\t\tvalue.then((response) => {\n\t\t\t\t\t\t\tresolve(response);\n\t\t\t\t\t\t});\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresolve(value);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tresolve(null);\n\t\t\t\t}\n\t\t\t}).then(response => {\n\t\t\t\tif (isArray(response)) {\n\t\t\t\t\treturn response.map(el => ({\n\t\t\t\t\t\t[name]: { ...defaultValidatableFieldMeta, ...el }\n\t\t\t\t\t}));\n\t\t\t\t} else if (isObject(response)) {\n\t\t\t\t\treturn {\n\t\t\t\t\t\t[name]: { ...defaultValidatableFieldMeta, ...response }\n\t\t\t\t\t};\n\t\t\t\t} else {\n\t\t\t\t\treturn defaultValidatableFieldMeta;\n\t\t\t\t}\n\t\t\t});\n\t\t},\n\t\tvalidate(field) {\n\t\t\tconst name = isObject(field) ? field.getName() : field;\n\t\t\treturn this.onStartValidate({ form: this, field: name }).then(\n\t\t\t\t(data) => {\n\t\t\t\t\tthis.onEndValidate({\n\t\t\t\t\t\tform: this.interface(),\n\t\t\t\t\t\tfield,\n\t\t\t\t\t\tdata\n\t\t\t\t\t});\n\t\t\t\t\tthis.updateForm();\n\t\t\t\t\treturn Vue.nextTick();\n\t\t\t\t}\n\t\t\t);\n\t\t},\n\t\tupdateMeta(values) {\n\t\t\tconst normalizedValues = flattenMeta(values);\n\t\t\tfor (const name of ownProperties(flattenMeta)) {\n\t\t\t\tif (this.fields[name]) {\n\t\t\t\t\tthis.setFieldMeta(name, normalizedValues[name]);\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\tsubmit(params) {\n\t\t\tconst form = this.interface();\n\t\t\tthis.onStartSubmit({ form, params }).then(() => {\n\t\t\t\tthis.onEndSubmit({ form, params });\n\t\t\t});\n\t\t},\n\t\tupdateForm() {\n\t\t\tconst { formMeta } = this.settings;\n\n\t\t\tconst update = {};\n\t\t\tformMeta.forEach(meta => {\n\t\t\t\tif (isFunction(meta.computed)) {\n\t\t\t\t\tconst value = meta.computed({ form: this.interface() });\n\t\t\t\t\tif (!isEqual(this.meta[meta.name], value)) {\n\t\t\t\t\t\tupdate[meta.name] = value;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t\tif (ownProperties(update).length) {\n\t\t\t\tthis.setMeta(update, true);\n\t\t\t}\n\t\t}\n\t},\n\trender(createElement) {\n\t\tconst form = this;\n\t\tconst properties = this.component === 'form' ? {\n\t\t\ton: {\n\t\t\t\tsubmit(event) {\n\t\t\t\t\tform.submit();\n\t\t\t\t\tevent.preventDefault();\n\t\t\t\t}\n\t\t\t}\n\t\t} : {};\n\t\treturn createElement(this.component, properties, [\n\t\t\tthis.$scopedSlots.default(this.interface())\n\t\t]);\n\t}\n};\n</script>\n","/**\n * Returns a function, that, as long as it continues to be invoked, will not\n * be triggered. The function will be called after it stops being called for\n * N milliseconds. If `immediate` is passed, trigger the function on the\n * leading edge, instead of the trailing. The function also has a property 'clear' \n * that is a function which will clear the timer to prevent previously scheduled executions. \n *\n * @source underscore.js\n * @see http://unscriptable.com/2009/03/20/debouncing-javascript-methods/\n * @param {Function} function to wrap\n * @param {Number} timeout in ms (`100`)\n * @param {Boolean} whether to execute at the beginning (`false`)\n * @api public\n */\nfunction debounce(func, wait, immediate){\n  var timeout, args, context, timestamp, result;\n  if (null == wait) wait = 100;\n\n  function later() {\n    var last = Date.now() - timestamp;\n\n    if (last < wait && last >= 0) {\n      timeout = setTimeout(later, wait - last);\n    } else {\n      timeout = null;\n      if (!immediate) {\n        result = func.apply(context, args);\n        context = args = null;\n      }\n    }\n  };\n\n  var debounced = function(){\n    context = this;\n    args = arguments;\n    timestamp = Date.now();\n    var callNow = immediate && !timeout;\n    if (!timeout) timeout = setTimeout(later, wait);\n    if (callNow) {\n      result = func.apply(context, args);\n      context = args = null;\n    }\n\n    return result;\n  };\n\n  debounced.clear = function() {\n    if (timeout) {\n      clearTimeout(timeout);\n      timeout = null;\n    }\n  };\n  \n  debounced.flush = function() {\n    if (timeout) {\n      result = func.apply(context, args);\n      context = args = null;\n      \n      clearTimeout(timeout);\n      timeout = null;\n    }\n  };\n\n  return debounced;\n};\n\n// Adds compatibility for ES modules\ndebounce.debounce = debounce;\n\nmodule.exports = debounce;\n","<script>\nimport debounce from 'debounce';\nimport { getValue, isFunction, isObject, isString, isUndefined, isArray } from '../service/common';\nimport { getValidator } from '../service/core';\n\nexport const fieldDefaults = {\n\tbehavior: {\n\t\tonMount({ field, form }) {\n\t\t\tif (getValue({ ...form.validationOptions, ...field.validationOptions }, 'onMount', false)) {\n\t\t\t\tform.validate(field.name);\n\t\t\t}\n\t\t},\n\t\tonFocus({ event, field, form }) {\n\n\t\t},\n\t\tonBlur({ event, field, form }) {\n\t\t\tform.setFieldMeta(field.name, {\n\t\t\t\ttouched: true\n\t\t\t});\n\t\t\tif (getValue({ ...form.validationOptions, ...field.validationOptions }, 'onBlur', true)) {\n\t\t\t\tform.validate(field.name);\n\t\t\t}\n\t\t},\n\t\tonInput({ field, form }) {\n\t\t\tif (!field.meta.dirty) {\n\t\t\t\tform.setFieldMeta(field.name, {\n\t\t\t\t\tdirty: true\n\t\t\t\t});\n\t\t\t}\n\t\t},\n\t\tonValidate({ field, form }) {\n\t\t\tconst validation = field.validation;\n\t\t\tif (!isUndefined(validation)) {\n\t\t\t\tif (isFunction(validation)) {\n\t\t\t\t\treturn validation(field.value, { form, field });\n\t\t\t\t} else if (isArray(validation)) {\n\t\t\t\t\treturn validation.map(v => isFunction(v) ? v(field.value, { form, field }) : {} );\n\t\t\t\t} else if (isString(validation) || isObject(validation)) {\n\t\t\t\t\treturn getValidator(validation)(field.value, { form, field });\n\t\t\t\t}\n\t\t\t\tconsole.warn(`Can't process the validator ${validation}`);\n\t\t\t}\n\t\t\treturn form.settings.defaultFieldMeta;\n\t\t}\n\t}\n};\n\nexport default {\n\tinject: ['$form'],\n\tmodel: {\n\t\tprop: 'value',\n\t\tevent: 'change'\n\t},\n\tprops: {\n\t\tcomponent: {\n\t\t\ttype: [String, Object],\n\t\t\tdefault: 'span'\n\t\t},\n\t\tvalue: {},\n\t\tdefaultValue: {\n\t\t\tdefault: ''\n\t\t},\n\t\tvalidation: {\n\t\t\ttype: [String, Function, Object],\n\t\t},\n\t\tname: {\n\t\t\ttype: String,\n\t\t},\n\t\tonFocus: {\n\t\t\ttype: Function,\n\t\t\tdefault: fieldDefaults.behavior.onChangeField\n\t\t},\n\t\tonBlur: {\n\t\t\ttype: Function,\n\t\t\tdefault: fieldDefaults.behavior.onBlur\n\t\t},\n\t\tonInput: {\n\t\t\ttype: Function,\n\t\t\tdefault: fieldDefaults.behavior.onInput\n\t\t},\n\t\tonChange: {\n\t\t\ttype: Function,\n\t\t\tdefault: fieldDefaults.behavior.onChange\n\t\t},\n\t\tonValidate: {\n\t\t\ttype: Function,\n\t\t\tdefault: fieldDefaults.behavior.onValidate\n\t\t},\n\t\tonMount: {\n\t\t\ttype: Function,\n\t\t\tdefault: fieldDefaults.behavior.onMount\n\t\t}\n\t},\n\tdata() {\n\t\treturn {\n\t\t\tid: null,\n\t\t};\n\t},\n\tcomputed: {\n\t\t$name() {\n\t\t\treturn this.name || this.id;\n\t\t},\n\t\t$value() {\n\t\t\tif (this.controlled) {\n\t\t\t\treturn this.value;\n\t\t\t} else {\n\t\t\t\treturn this.$form.fields[this.$name] ? this.$form.fields[this.$name].value : null;\n\t\t\t}\n\t\t},\n\t\t$meta() {\n\t\t\treturn this.$form.fields[this.$name] ? this.$form.fields[this.$name].meta : {};\n\t\t},\n\t\tcontrolled() {\n\t\t\treturn typeof this.value !== 'undefined';\n\t\t}\n\t},\n\twatch: {\n\t\tvalue(value) {\n\t\t\tthis.$form.setFieldValue(this.$name, value, {\n\t\t\t\tforced: true,\n\t\t\t\tinternal: true\n\t\t\t});\n\t\t},\n\t\tname(name, oldName) {\n\t\t\tif (this.$form) {\n\t\t\t\tthis.$form.unmountField(oldName);\n\t\t\t\tthis.$nextTick(() => {\n\t\t\t\t\tthis.$form.mountField(this);\n\t\t\t\t\tif (this.onMount) {\n\t\t\t\t\t\tthis.onMount({ field: this.interface(), form: this.$form });\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t},\n\tcreated() {\n\t\tif (!this.$form) {\n\t\t\tthrow new Error(`Can't create the Field instance (name: ${this.$name}) because it's not contained in any form`);\n\t\t} else {\n\t\t\tthis.$form.mountField(this);\n\t\t\tif (this.onMount) {\n\t\t\t\tthis.onMount({ field: this.interface(), form: this.$form });\n\t\t\t}\n\t\t}\n\t},\n\tdestroyed() {\n\t\tif (this.$form) {\n\t\t\tthis.$form.unmountField(this);\n\t\t}\n\t},\n\tmethods: {\n\t\tinterface() {\n\t\t\tconst self = this;\n\t\t\treturn {\n\t\t\t\tmounted: true,\n\t\t\t\tcontrolled: this.controlled,\n\t\t\t\tname: this.$name,\n\t\t\t\tget meta() {\n\t\t\t\t\treturn self.$meta;\n\t\t\t\t},\n\t\t\t\tset meta(value) {\n\t\t\t\t\tself.$form.setFieldMeta(self.$name, value);\n\t\t\t\t},\n\t\t\t\tget value() {\n\t\t\t\t\treturn self.$value;\n\t\t\t\t},\n\t\t\t\tset value(value) {\n\t\t\t\t\tself.$form.setFieldValue(self.$name, value).then(() => {\n\t\t\t\t\t\tdebounce(\n\t\t\t\t\t\t\tself.$form.validate(self.$name),\n\t\t\t\t\t\t\tgetValue({ ...self.$form.validationOptions, ...self.validationOptions }, 'debounce', 0)\n\t\t\t\t\t\t);\n\t\t\t\t\t});\n\t\t\t\t},\n\t\t\t\t// Events\n\t\t\t\tevents: {\n\t\t\t\t\tblur: this.handleBlur,\n\t\t\t\t\tfocus: this.handleFocus,\n\t\t\t\t\tinput: this.handleInput,\n\t\t\t\t},\n\t\t\t\t// Props\n\t\t\t\tvalidation: this.validation,\n\t\t\t\tvalidationOptions: this.validationOptions,\n\t\t\t\tref: this\n\t\t\t};\n\t\t},\n\t\tgetName() {\n\t\t\treturn this.$name;\n\t\t},\n\t\tgetValue() {\n\t\t\treturn this.$value;\n\t\t},\n\t\tgetMeta() {\n\t\t\treturn this.$meta;\n\t\t},\n\t\tgetForm() {\n\t\t\treturn this.$form;\n\t\t},\n\t\tgetInitialValue() {\n\t\t\treturn this.defaultValue;\n\t\t},\n\t\thandleFocus(event) {\n\t\t\tif (isFunction(this.onFocus)) {\n\t\t\t\tthis.onFocus({ event, field: this.interface(), form: this.getForm() });\n\t\t\t}\n\t\t},\n\t\thandleBlur(event) {\n\t\t\tif (isFunction(this.onBlur)) {\n\t\t\t\tthis.onBlur({ event, field: this.interface(), form: this.getForm() });\n\t\t\t}\n\t\t},\n\t\thandleInput(event) {\n\t\t\tif (isFunction(this.onInput)) {\n\t\t\t\tthis.onInput({ event, field: this.interface(), form: this.getForm() });\n\t\t\t}\n\t\t},\n\t},\n\trender(createElement) {\n\t\tif (this.id) {\n\t\t\treturn createElement(this.component, [\n\t\t\t\tthis.$scopedSlots.default(this.interface())\n\t\t\t]);\n\t\t} else {\n\t\t\treturn createElement(this.component);\n\t\t}\n\t}\n};\n</script>\n","<script>\nimport { updateArray, isFunction, isObject, isString, isUndefined, getValue } from '../service/common';\nimport { getValidator } from \"../service/core\";\n\nexport const fieldArrayDefaults = {\n\tbehavior: {\n\t\tonValidate({ field, form }) {\n\t\t\tconst validate = field.validate;\n\t\t\tif (!isUndefined(validate)) {\n\t\t\t\tif (isFunction(validate)) {\n\t\t\t\t\treturn validate(field.value);\n\t\t\t\t} else if (isString(validate) || isObject(validate)) {\n\t\t\t\t\treturn getValidator(validate)(field.value);\n\t\t\t\t}\n\t\t\t\tconsole.warn(`Can't process the validator ${validate}`);\n\t\t\t}\n\t\t\treturn {};\n\t\t},\n\t\tonMount({ field, form }) {\n\t\t\tif (getValue({ ...form.validationOptions, ...field.validationOptions }, 'onMount', false)) {\n\t\t\t\tform.validate(field.name);\n\t\t\t}\n\t\t},\n\t}\n};\n\nexport default {\n\tinject: ['$form'],\n\tmodel: {\n\t\tprop: 'value',\n\t\tevent: 'change'\n\t},\n\tprops: {\n\t\tname: {\n\t\t\ttype: String,\n\t\t},\n\t\tcomponent: {\n\t\t\ttype: [String, Object],\n\t\t\tdefault: 'span'\n\t\t},\n\t\tdefaultValue: {\n\t\t\ttype: Array,\n\t\t\tdefault() {\n\t\t\t\treturn [];\n\t\t\t}\n\t\t},\n\t\tvalidation: {\n\t\t\ttype: Function,\n\t\t},\n\t\tvalidationOptions: {\n\t\t\ttype: [String, Function, Object],\n\t\t},\n\t\tonMount: {\n\t\t\ttype: Function,\n\t\t\tdefault: fieldArrayDefaults.behavior.onMount\n\t\t},\n\t\tonValidate: {\n\t\t\ttype: Function,\n\t\t\tdefault: fieldArrayDefaults.behavior.onValidate\n\t\t}\n\t},\n\tdata() {\n\t\treturn {\n\t\t\tid: null,\n\t\t\titems: [],\n\t\t\tnames: []\n\t\t};\n\t},\n\tcomputed: {\n\t\t$name() {\n\t\t\treturn this.name;\n\t\t},\n\t\tvalues() {\n\t\t\treturn this.getField().value;\n\t\t},\n\t\tfield() {\n\t\t\treturn this.getField();\n\t\t},\n\t\tmeta() {\n\t\t\treturn this.field ? this.field.meta : {};\n\t\t},\n\t},\n\tdestroyed() {\n\t\tif (this.$form) {\n\t\t\tthis.$form.unmountField(this);\n\t\t}\n\t},\n\tcreated() {\n\t\tif (!this.$form) {\n\t\t\tthrow new Error(`Can't create the Field instance (name: ${this.$name}) because it's not contained in any form`);\n\t\t} else {\n\t\t\tthis.$form.mountField(this);\n\t\t\tif (this.onMount) {\n\t\t\t\tthis.onMount({ field: this.interface(), form: this.$form });\n\t\t\t}\n\t\t\tthis.$watch(this.getField, (data) => {\n\t\t\t\tif (data) {\n\t\t\t\t\tupdateArray(this.names, data.value.map((el, index) => `${this.$name}[${index}]`));\n\t\t\t\t}\n\t\t\t}, { deep: true, immediate: true });\n\t\t}\n\t},\n\tmethods: {\n\t\tinterface() {\n\t\t\tconst self = this;\n\t\t\treturn {\n\t\t\t\tpush: this.push,\n\t\t\t\tpop: this.pop,\n\t\t\t\tshift: this.shift,\n\t\t\t\tunshift: this.unshift,\n\t\t\t\tinsert: this.insert,\n\t\t\t\tremove: this.remove,\n\t\t\t\treplace: this.replace,\n\t\t\t\tswap: this.swap,\n\t\t\t\tget validation() {\n\t\t\t\t\treturn self.validation;\n\t\t\t\t},\n\t\t\t\tget validationOptions() {\n\t\t\t\t\treturn self.validationOptions;\n\t\t\t\t},\n\t\t\t\tget name() {\n\t\t\t\t\treturn self.$name;\n\t\t\t\t},\n\t\t\t\tget meta() {\n\t\t\t\t\treturn self.meta;\n\t\t\t\t},\n\t\t\t\tset meta(value) {\n\t\t\t\t\tself.$form.setFieldMeta(self.$name, value);\n\t\t\t\t},\n\t\t\t\tget mounted() {\n\t\t\t\t\treturn true;\n\t\t\t\t},\n\t\t\t\tget controlled() {\n\t\t\t\t\treturn self.controlled;\n\t\t\t\t},\n\t\t\t\tget names() {\n\t\t\t\t\treturn self.names;\n\t\t\t\t},\n\t\t\t};\n\t\t},\n\t\tgetName() {\n\t\t\treturn this.$name;\n\t\t},\n\t\tgetField() {\n\t\t\treturn this.$form.fields[this.$name];\n\t\t},\n\t\tgetInitialValue() {\n\t\t\treturn [];\n\t\t},\n\t\tpush(value) {\n\t\t\tthis.$form.setFieldValue(this.$name, [...this.values, value]);\n\t\t},\n\t\tshift() {\n\t\t\tthis.$form.setFieldValue(this.$name, this.values.slice(1));\n\t\t},\n\t\tunshift(value) {\n\t\t\tthis.$form.setFieldValue(this.$name, [value, ...this.values]);\n\t\t},\n\t\tinsert(index, value) {\n\t\t\tthis.$form.setFieldValue(this.$name, [...this.values.slice(0, index), value, ...this.values.slice(index)]);\n\t\t},\n\t\tremove(index) {\n\t\t\tthis.$form.setFieldValue(this.$name, [...this.values.slice(0, index), ...this.values.slice(index + 1)]);\n\t\t},\n\t\treplace(index, value) {\n\t\t\tthis.$form.setFieldValue(this.$name, [...this.values.slice(0, index), value, ...this.values.slice(index + 1)]);\n\t\t},\n\t\tpop() {\n\t\t\tthis.$form.setFieldValue(this.$name, [...this.values.slice(0, this.values.length - 1)]);\n\t\t},\n\t\tswap(firstIndex, secondIndex) {\n\t\t\tconst array = [...this.values];\n\t\t\tconst value = array[secondIndex];\n\t\t\tarray[secondIndex] = array[firstIndex];\n\t\t\tarray[firstIndex] = value;\n\t\t\tthis.$form.setFieldValue(this.getName(), array);\n\t\t}\n\t},\n\trender(createElement) {\n\t\treturn createElement(this.component, [\n\t\t\tthis.$scopedSlots.default(this.interface())\n\t\t]);\n\t}\n};\n</script>\n","import Vue from 'vue';\n\nexport function customize(component, props) {\n\treturn {\n\t\tinheritAttrs: true,\n\t\trender(createElement) {\n\t\t\treturn createElement(component, {\n\t\t\t\tattrs: { ...props, ...this.$attrs },\n\t\t\t\ton: this.$listeners,\n\t\t\t\tscopedSlots: this.$scopedSlots,\n\t\t\t})\n\t\t}\n\t}\n}\n"],"names":["memoize","fn","options","cache","cacheDefault","serializer","serializerDefault","strategy","strategyDefault","isPrimitive","value","monadic","arg","cacheKey","computedValue","get","call","set","variadic","args","Array","prototype","slice","arguments","apply","assemble","context","serialize","bind","length","create","strategyVariadic","strategyMonadic","JSON","stringify","ObjectWithoutPrototypeCache","Object","has","key","module","INFINITY","ESCAPE_CHARACTERS","PROP_NAMES","RegExp","deepcopy","obj","parse","isUndefined","isPromise","then","isString","isObject","isArray","isFunction","toString","Function","isSymbol","isInteger","String","Math","floor","Number","getValue","defaultValue","ownProperties","keys","getIn","object","pathString","path","toPath","index","undefined","insertToArray","array","splice","i","push","setValueByPath","previousElement","isLast","currentElement","nextValue","Vue","removeValueByPath","removedElement","pop","delete","freeze","assign","stringToPath","string","delimiter","result","charCodeAt","replace","match","expression","quote","subString","trim","toKey","map","isEqual","a","b","defaultMergeAlgorithm","source","destination","name","filter","find","mergeValidations","settings","mergeAlgorithm","blocks","reduce","block","concat","forEach","fields","meta","default","console","warn","updateArray","newValue","flattenMeta","queue","element","parent","node","field","branch","arrayToObject","names","core","validators","install","installed","vm","data","forms","mixin","beforeCreate","init","ref","$data","interface","$form","getValidator","rules","rule","split","params","scheme","arrayParams","validator","Promise","resolve","reject","all","validations","registerValidator","debounce","func","wait","immediate","timeout","timestamp","later","last","Date","now","setTimeout","debounced","callNow","clear","clearTimeout","flush","customize","component","props","inheritAttrs","render","createElement","attrs","$attrs","on","$listeners","scopedSlots","$scopedSlots"],"mappings":"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"}